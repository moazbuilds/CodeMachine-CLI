---
title: "Controls"
description: "Understand how workflow execution is controlled - signals, modes, state, and recovery."
sidebarTitle: "Controls"
---

**How execution is controlled at runtime.**

## Signals

Signals are user-initiated events that interrupt or redirect workflow execution. They let you intervene while agents are running.

| Signal | What It Does |
|--------|--------------|
| **Pause** | Stops execution, switches to manual mode |
| **Skip** | Moves to the next step without completing the current one |
| **Stop** | Terminates the workflow entirely |
| **Mode Toggle** | Switches between manual and auto mode |
| **Return to Controller** | Goes back to controller view (if controller exists) |

Signals are context-aware. You can only send signals that make sense for the current workflow state.

<Note>
  Signals come from the user. Directives come from agents. Both control execution, but from different sources. [Learn about directives →](../components#directives)
</Note>

---

## Modes

Two modes determine who drives the workflow: **manual** and **auto**.

**Manual mode:** You control advancement. Agents wait for you to proceed between steps and prompts.

**Auto mode:** The system controls advancement. Either a controller agent makes decisions, or agents auto-advance without waiting.

You can switch modes at any time during execution.

### Who Drives the Workflow?

The actual behavior depends on three factors:

- **Mode** — Manual or Auto
- **Paused** — Whether you've paused execution
- **Agent Interactivity** — Whether the agent is configured to wait for input

| Auto Mode | Paused | Agent Interactive | Who Drives |
|-----------|--------|-------------------|------------|
| OFF | — | Yes | User |
| OFF | — | No | User (forced, with warning) |
| ON | YES | Any | User (pause overrides) |
| ON | NO | Yes | Controller |
| ON | NO | No | System (fully autonomous) |

**The rule:** Pausing always gives you control. Auto mode only takes over when not paused.

### Four Behaviors

| Behavior | Description |
|----------|-------------|
| **User drives** | You send input. Agent waits for you. |
| **Controller drives** | Controller agent sends input. Agent waits for controller. |
| **Fully autonomous** | System auto-advances. No waiting. |
| **Forced** | Agent designed to auto-advance but mode is manual. Falls back to user control with a warning. |

---

## State

Workflows move through defined states during execution. State determines what actions are available and what the workflow is waiting for.

| State | Meaning |
|-------|---------|
| **idle** | Workflow has not started |
| **running** | An agent is actively executing |
| **awaiting** | Workflow is waiting for user input |
| **delegated** | Workflow is waiting for controller to decide |
| **completed** | All steps finished successfully |
| **stopped** | User terminated the workflow |
| **error** | A fatal error occurred |

### How State Changes

State transitions follow a predictable pattern:

**Starting:** `idle` → `running`

**During execution:**
- Agent needs input → `running` → `awaiting`
- Controller takes over → `running` → `delegated`
- User sends input → `awaiting` → `running`
- Controller decides → `delegated` → `running`

**Ending:**
- All steps complete → `running` → `completed`
- User stops → `running` → `stopped`
- Fatal error → `running` → `error`

Understanding state helps you know why a workflow is waiting and what action will move it forward.

---

## Recovery

Workflows are designed to survive interruptions. If the process crashes, loses connection, or terminates unexpectedly, CodeMachine can resume from where it left off.

### How Recovery Works

1. **Detection** — On startup, CodeMachine checks if a step was running but never completed
2. **Restoration** — Previous state is loaded from the persisted session
3. **Resumption** — Workflow continues based on mode:
   - Auto mode: Sends continuation prompt to agent
   - Manual mode: Pauses and waits for your input

### What Gets Persisted

Workflow state is continuously saved to `.codemachine/template.json`:

- Current step index
- Prompt queue progress (for chained prompts)
- Step completion status
- Agent session IDs
- Monitoring IDs for logs

### Recovery Scenarios

| Scenario | Outcome |
|----------|---------|
| Process crash mid-step | Resumes from last checkpoint |
| Machine restart | Resumes on next workflow start |
| User closes terminal | State preserved, resume anytime |
| Network timeout | Reconnects if session is still valid |

<Note>
  Recovery depends on proper session configuration. Each agent needs a unique session ID for reliable resumption.
</Note>

---

## Signals vs Directives

Both influence workflow execution, but they serve different purposes:

| | Signals | Directives |
|-|---------|------------|
| **Source** | User | Agent |
| **When** | Anytime during execution | After a step completes |
| **Purpose** | User intervention | Agent-controlled flow |
| **Examples** | Pause, Skip, Stop | Loop, Checkpoint, Trigger |

Signals let you take control. Directives let agents request what should happen next.

## Next Steps

- [Building Your First Workflow →](#) - Create a custom workflow
- [Keyboard Shortcuts Reference →](#) - All available shortcuts
